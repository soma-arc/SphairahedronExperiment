!function(e){function t(r){if(n[r])return n[r].exports;var i=n[r]={i:r,l:!1,exports:{}};return e[r].call(i.exports,i,i.exports,t),i.l=!0,i.exports}var n={};t.m=e,t.c=n,t.i=function(e){return e},t.d=function(e,n,r){t.o(e,n)||Object.defineProperty(e,n,{configurable:!1,enumerable:!0,get:r})},t.n=function(e){var n=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(n,"a",n),n},t.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},t.p="",t(t.s=13)}([function(e,t,n){"use strict";function r(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}Object.defineProperty(t,"__esModule",{value:!0});var i=function(){function e(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}return function(t,n,r){return n&&e(t.prototype,n),r&&e(t,r),t}}(),s=function(){function e(t,n){r(this,e),this.x=t,this.y=n}return i(e,[{key:"add",value:function(t){return new e(this.x+t.x,this.y+t.y)}},{key:"sub",value:function(t){return new e(this.x-t.x,this.y-t.y)}},{key:"prod",value:function(t){return new e(this.x*t.x,this.y*t.y)}},{key:"div",value:function(t){return new e(this.x/t.x,this.y/t.y)}},{key:"scale",value:function(t){return new e(this.x*t,this.y*t)}},{key:"length",value:function(){return Math.sqrt(this.x*this.x+this.y*this.y)}},{key:"lengthSq",value:function(){return this.x*this.x+this.y*this.y}},{key:"normalize",value:function(){return this.scale(1/this.length())}},{key:"eq",value:function(t){return Math.abs(this.x-t.x)<=e.EPSILON&&Math.abs(this.y-t.y<=e.EPSILON)}},{key:"cloneDeeply",value:function(){return new e(this.x,this.y)}}],[{key:"normalize",value:function(e){return e.normalize()}},{key:"dot",value:function(e,t){return e.x*t.x+e.y*t.y}},{key:"distance",value:function(e,t){var n=e.sub(t);return Math.sqrt(n.x*n.x+n.y*n.y)}},{key:"EPSILON",get:function(){return 1e-5}}]),e}();t.default=s},function(e,t,n){"use strict";function r(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}Object.defineProperty(t,"__esModule",{value:!0});var i=function(){function e(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}return function(t,n,r){return n&&e(t.prototype,n),r&&e(t,r),t}}(),s=function(){function e(t,n,i){r(this,e),this.x=t,this.y=n,this.z=i}return i(e,[{key:"add",value:function(t){return new e(this.x+t.x,this.y+t.y,this.z+t.z)}},{key:"sub",value:function(t){return new e(this.x-t.x,this.y-t.y,this.z-t.z)}},{key:"prod",value:function(t){return new e(this.x*t.x,this.y*t.y,this.z*t.z)}},{key:"div",value:function(t){return new e(this.x/t.x,this.y/t.y,this.z/t.z)}},{key:"scale",value:function(t){return new e(this.x*t,this.y*t,this.z*t)}},{key:"length",value:function(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}},{key:"lengthSq",value:function(){return this.x*this.x+this.y*this.y+this.z*this.z}},{key:"normalize",value:function(){return this.scale(1/this.length())}},{key:"rotateAroundX",value:function(t){var n=Math.cos(t),r=Math.sin(t);return new e(this.x,n*this.y+-r*this.z,r*this.y+n*this.z)}},{key:"rotateAroundY",value:function(t){var n=Math.cos(t),r=Math.sin(t);return new e(n*this.x+r*this.z,this.y,-r*this.x+n*this.z)}},{key:"rotateAroundZ",value:function(t){var n=Math.cos(t),r=Math.sin(t);return new e(n*this.x-r*this.y,r*this.x+n*this.y,this.z)}}],[{key:"normalize",value:function(e){return e.normalize()}},{key:"dot",value:function(e,t){return e.x*t.x+e.y*t.y+e.z*t.z}},{key:"cross",value:function(t,n){return new e(t.y*n.z-t.z*n.y,t.z*n.x-t.x*n.z,t.x*n.y-t.y*n.x)}},{key:"distance",value:function(e,t){var n=e.sub(t);return Math.sqrt(n.x*n.x+n.y*n.y)}}]),e}();t.default=s},function(e,t,n){"use strict";function r(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}Object.defineProperty(t,"__esModule",{value:!0});var i=function(){function e(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}return function(t,n,r){return n&&e(t.prototype,n),r&&e(t,r),t}}(),s=function(){function e(t){r(this,e),this.canvasId=t,this.canvas=document.getElementById(t),this.pixelRatio=1,this.isRendering=!1,this.boundMouseDownListener=this.mouseDownListener.bind(this),this.boundMouseUpListener=this.mouseUpListener.bind(this),this.boundMouseWheelListener=this.mouseWheelListener.bind(this),this.boundMouseMoveListener=this.mouseMoveListener.bind(this),this.boundDblClickLisntener=this.mouseDblClickListener.bind(this),this.boundKeydown=this.keydownListener.bind(this),this.boundKeyup=this.keyupListener.bind(this),this.canvas.addEventListener("mousedown",this.boundMouseDownListener),this.canvas.addEventListener("mouseup",this.boundMouseUpListener),this.canvas.addEventListener("wheel",this.boundMouseWheelListener),this.canvas.addEventListener("mousemove",this.boundMouseMoveListener),this.canvas.addEventListener("dblclick",this.boundDblClickLisntener),this.canvas.addEventListener("keydown",this.boundKeydown),this.canvas.addEventListener("keyup",this.boundKeyup),this.canvas.addEventListener("contextmenu",function(e){return e.preventDefault()}),this.renderCallback=this.render.bind(this)}return i(e,[{key:"resizeCanvas",value:function(){var e=this.canvas.parentElement;this.canvas.style.width=e.clientWidth+"px",this.canvas.style.height=e.clientHeight+"px",this.canvas.width=e.clientWidth*this.pixelRatio,this.canvas.height=e.clientHeight*this.pixelRatio,this.canvasRatio=this.canvas.width/this.canvas.height/2}},{key:"mouseWheelListener",value:function(e){}},{key:"mouseDownListener",value:function(e){}},{key:"mouseDblClickListener",value:function(e){}},{key:"mouseUpListener",value:function(e){}},{key:"mouseMoveListener",value:function(e){}},{key:"keydownListener",value:function(e){}},{key:"keyupListener",value:function(e){}},{key:"render",value:function(){}},{key:"dataURLtoBlob",value:function(e){for(var t=e.split(","),n=t[0].match(/:(.*?);/)[1],r=atob(t[1]),i=r.length,s=new Uint8Array(i);i--;)s[i]=r.charCodeAt(i);return new Blob([s],{type:n})}},{key:"saveImage",value:function(e,t,n,r){var i=new Uint8Array(t*n*4),s=e.UNSIGNED_BYTE;e.readPixels(0,0,t,n,e.RGBA,s,i);var o=document.createElement("canvas");o.width=t,o.height=n;var a=o.getContext("2d"),c=a.createImageData(t,n);c.data.set(i),a.putImageData(c,0,0);var u=document.createElement("a"),h=o.toDataURL(),f=this.dataURLtoBlob(h);u.href=URL.createObjectURL(f),u.download=r,u.click()}}],[{key:"MOUSE_BUTTON_LEFT",get:function(){return 0}},{key:"MOUSE_BUTTON_WHEEL",get:function(){return 1}},{key:"MOUSE_BUTTON_RIGHT",get:function(){return 2}}]),e}();t.default=s},function(e,t,n){"use strict";function r(e){new l;return e.getContext("webgl2")}function i(e,t){var n=e.createBuffer();return e.bindBuffer(e.ARRAY_BUFFER,n),e.bufferData(e.ARRAY_BUFFER,new Float32Array(t),e.STATIC_DRAW),e.bindBuffer(e.ARRAY_BUFFER,null),n}function s(e){return i(e,d)}function o(e,t){new l;e.linkProgram(t),e.useProgram(t)}function a(e,t,n,r){var i=(new l,e.createShader(r));e.shaderSource(i,t),e.compileShader(i),e.attachShader(n,i)}function c(e,t,n,r,i,s){var o=e.createTexture();return e.bindTexture(e.TEXTURE_2D,o),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MAG_FILTER,e.NEAREST),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MIN_FILTER,e.NEAREST),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE),e.texImage2D(e.TEXTURE_2D,0,e.RGB,t,n,0,e.RGB,s,null),e.bindTexture(e.TEXTURE_2D,null),o}function u(e,t,n,r){for(var i=[],s=0;s<r;s++)i.push(c(e,t,n,e.RGB,e.RGB,e.UNSIGNED_BYTE,r));return i}function h(e,t,n,r,i,s){var o=e.createTexture();return e.bindTexture(e.TEXTURE_2D,o),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MAG_FILTER,e.NEAREST),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MIN_FILTER,e.NEAREST),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE),e.texImage2D(e.TEXTURE_2D,0,e.RGBA,t,n,0,e.RGBA,s,null),e.bindTexture(e.TEXTURE_2D,null),o}function f(e,t,n,r){for(var i=[],s=0;s<r;s++)i.push(c(e,t,n,e.RGBA,e.RGBA,e.UNSIGNED_BYTE,r));return i}Object.defineProperty(t,"__esModule",{value:!0});var l=function(){function e(){this.captured=[]}return e.prototype._capt=function(e,t){return this.captured.push({value:e,espath:t}),e},e.prototype._expr=function(e,t){var n=this.captured;return this.captured=[],{powerAssertContext:{value:e,events:n},source:t}},e}();t.GetWebGL2Context=r,t.CreateStaticVbo=i,t.CreateSquareVbo=s,t.LinkProgram=o,t.AttachShader=a,t.CreateRGBTexture2D=c,t.CreateRGBTextures=u,t.CreateRGBATexture2D=h,t.CreateRGBATextures=f;var d=[-1,-1,-1,1,1,-1,1,1]},function(e,t){e.exports="#version 300 es\n\nin vec2 a_vertex;\nout vec2 v_texCoord;\n\nvoid main() {\n    v_texCoord = a_vertex.xy * 0.5 + 0.5;\n    gl_Position = vec4(a_vertex, 0., 1.0);\n}\n"},function(e,t,n){"use strict";function r(e){return e&&e.__esModule?e:{default:e}}function i(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function s(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!t||"object"!=typeof t&&"function"!=typeof t?e:t}function o(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t)}Object.defineProperty(t,"__esModule",{value:!0});var a=function(){function e(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}return function(t,n,r){return n&&e(t.prototype,n),r&&e(t,r),t}}(),c=n(2),u=r(c),h=n(0),f=r(h),l=n(3),d=n(4),p=function(e){function t(e,n,r){i(this,t);var o=s(this,(t.__proto__||Object.getPrototypeOf(t)).call(this,e));return o.canvasRatio=o.canvas.width/o.canvas.height/2,o.spheirahedra=n,o.gl=(0,l.GetWebGL2Context)(o.canvas),o.vertexBuffer=(0,l.CreateSquareVbo)(o.gl),o.renderProgram=o.gl.createProgram(),(0,l.AttachShader)(o.gl,d,o.renderProgram,o.gl.VERTEX_SHADER),(0,l.AttachShader)(o.gl,r,o.renderProgram,o.gl.FRAGMENT_SHADER),(0,l.LinkProgram)(o.gl,o.renderProgram),o.renderCanvasVAttrib=o.gl.getAttribLocation(o.renderProgram,"a_vertex"),o.gl.enableVertexAttribArray(o.renderCanvasVAttrib),o.getRenderUniformLocations(),o.mouseState={isPressing:!1,prevPosition:new f.default(0,0),button:-1},o.scale=5,o.scaleFactor=1.25,o.translate=new f.default(0,0),o}return o(t,e),a(t,[{key:"calcCanvasCoord",value:function(e,t){var n=this.canvas.getBoundingClientRect();return new f.default(this.scale*((e-n.left)*this.pixelRatio/this.canvas.height-this.canvasRatio),this.scale*-((t-n.top)*this.pixelRatio/this.canvas.height-.5))}},{key:"calcSceneCoord",value:function(e,t){return this.calcCanvasCoord(e,t).add(this.translate)}},{key:"getRenderUniformLocations",value:function(){this.uniLocations=[],this.uniLocations.push(this.gl.getUniformLocation(this.renderProgram,"u_resolution")),this.uniLocations.push(this.gl.getUniformLocation(this.renderProgram,"u_geometry")),this.spheirahedra.setUniformLocations(this.gl,this.uniLocations,this.renderProgram)}},{key:"setRenderUniformValues",value:function(e,t){var n=0;this.gl.uniform2f(this.uniLocations[n++],e,t),this.gl.uniform3f(this.uniLocations[n++],this.translate.x,this.translate.y,this.scale),n=this.spheirahedra.setUniformValues(this.gl,this.uniLocations,n,this.scale)}},{key:"render",value:function(){this.gl.viewport(0,0,this.canvas.width,this.canvas.height),this.gl.useProgram(this.renderProgram),this.gl.bindBuffer(this.gl.ARRAY_BUFFER,this.vertexBuffer),this.gl.vertexAttribPointer(this.renderCanvasVAttrib,2,this.gl.FLOAT,!1,0,0),this.setRenderUniformValues(this.canvas.width,this.canvas.height),this.gl.drawArrays(this.gl.TRIANGLE_STRIP,0,4),this.gl.flush()}},{key:"mouseWheelListener",value:function(e){e.preventDefault(),e.deltaY<0?this.scale/=this.scaleFactor:this.scale*=this.scaleFactor,this.render()}},{key:"mouseDownListener",value:function(e){e.preventDefault(),this.canvas.focus();var t=this.calcSceneCoord(e.clientX,e.clientY);this.mouseState.button=e.button,e.button===u.default.MOUSE_BUTTON_LEFT&&this.spheirahedra.select(t,this.scale),this.mouseState.prevPosition=t,this.mouseState.prevTranslate=this.translate,this.mouseState.isPressing=!0}},{key:"mouseMoveListener",value:function(e){if(this.mouseState.isPressing){var t=this.calcSceneCoord(e.clientX,e.clientY);if(this.mouseState.button===u.default.MOUSE_BUTTON_LEFT){this.spheirahedra.move(t)&&this.render()}else this.mouseState.button===u.default.MOUSE_BUTTON_RIGHT&&(this.translate=this.translate.sub(t.sub(this.mouseState.prevPosition)),this.render())}}},{key:"mouseUpListener",value:function(e){this.mouseState.isPressing=!1}}]),t}(u.default);t.default=p},function(e,t,n){"use strict";function r(e){return e&&e.__esModule?e:{default:e}}function i(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function s(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!t||"object"!=typeof t&&"function"!=typeof t?e:t}function o(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t)}Object.defineProperty(t,"__esModule",{value:!0});var a=function(){function e(e,t){var n=[],r=!0,i=!1,s=void 0;try{for(var o,a=e[Symbol.iterator]();!(r=(o=a.next()).done)&&(n.push(o.value),!t||n.length!==t);r=!0);}catch(e){i=!0,s=e}finally{try{!r&&a.return&&a.return()}finally{if(i)throw s}}return n}return function(t,n){if(Array.isArray(t))return t;if(Symbol.iterator in Object(t))return e(t,n);throw new TypeError("Invalid attempt to destructure non-iterable instance")}}(),c=function(){function e(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}return function(t,n,r){return n&&e(t.prototype,n),r&&e(t,r),t}}(),u=n(2),h=r(u),f=n(0),l=r(f),d=n(1),p=r(d),v=n(12),m=n(3),y=n(4),x=function(e){function t(e,n,r){i(this,t);var o=s(this,(t.__proto__||Object.getPrototypeOf(t)).call(this,e));return o.spheirahedra=n,o.spheirahedra.addUpdateListener(o.render.bind(o)),o.pixelRatio=window.devicePixelRatio,o.camera=new v.CameraOnSphere(new p.default(0,0,0),Math.PI/3,1,new p.default(0,1,0)),o.cameraDistScale=1.25,o.gl=(0,m.GetWebGL2Context)(o.canvas),o.vertexBuffer=(0,m.CreateSquareVbo)(o.gl),o.renderProgram=o.gl.createProgram(),(0,m.AttachShader)(o.gl,y,o.renderProgram,o.gl.VERTEX_SHADER),(0,m.AttachShader)(o.gl,r,o.renderProgram,o.gl.FRAGMENT_SHADER),(0,m.LinkProgram)(o.gl,o.renderProgram),o.renderCanvasVAttrib=o.gl.getAttribLocation(o.renderProgram,"a_vertex"),o.gl.enableVertexAttribArray(o.renderCanvasVAttrib),o.getRenderUniformLocations(),o.mouseState={isPressing:!1,prevPosition:new l.default(0,0),button:-1},o}return o(t,e),c(t,[{key:"calcCanvasCoord",value:function(e,t){var n=this.canvas.getBoundingClientRect();return new l.default((e-n.left)*this.pixelRatio,(t-n.top)*this.pixelRatio)}},{key:"getRenderUniformLocations",value:function(){this.uniLocations=[],this.uniLocations.push(this.gl.getUniformLocation(this.renderProgram,"u_resolution")),this.camera.setUniformLocations(this.gl,this.uniLocations,this.renderProgram),this.spheirahedra.setUniformLocations(this.gl,this.uniLocations,this.renderProgram)}},{key:"setRenderUniformValues",value:function(e,t){var n=0;this.gl.uniform2f(this.uniLocations[n++],e,t),n=this.camera.setUniformValues(this.gl,this.uniLocations,n),n=this.spheirahedra.setUniformValues(this.gl,this.uniLocations,n)}},{key:"render",value:function(){this.gl.viewport(0,0,this.canvas.width,this.canvas.height),this.gl.useProgram(this.renderProgram),this.gl.bindBuffer(this.gl.ARRAY_BUFFER,this.vertexBuffer),this.gl.vertexAttribPointer(this.renderCanvasVAttrib,2,this.gl.FLOAT,!1,0,0),this.setRenderUniformValues(this.canvas.width,this.canvas.height),this.gl.drawArrays(this.gl.TRIANGLE_STRIP,0,4),this.gl.flush()}},{key:"mouseWheelListener",value:function(e){e.preventDefault(),e.deltaY<0?this.camera.cameraDistance/=this.cameraDistScale:this.camera.cameraDistance*=this.cameraDistScale,this.camera.update(),this.numSamples=0,this.render()}},{key:"mouseDownListener",value:function(e){e.preventDefault(),this.mouseState.isPressing=!0;var t=this.calcCanvasCoord(e.clientX,e.clientY);this.mouseState.prevPosition=t,this.mouseState.button=e.button,e.button===h.default.MOUSE_BUTTON_LEFT?this.camera.prevThetaPhi=new l.default(this.camera.theta,this.camera.phi):e.button===h.default.MOUSE_BUTTON_RIGHT&&(this.camera.prevTarget=this.camera.target)}},{key:"mouseDblClickListener",value:function(e){}},{key:"mouseUpListener",value:function(e){this.mouseState.isPressing=!1}},{key:"mouseMoveListener",value:function(e){if(e.preventDefault(),this.mouseState.isPressing){var t=this.calcCanvasCoord(e.clientX,e.clientY);if(this.mouseState.button===h.default.MOUSE_BUTTON_LEFT){var n=this.camera.prevThetaPhi;this.camera.theta=n.x+.01*(this.mouseState.prevPosition.x-t.x),this.camera.phi=n.y-.01*(this.mouseState.prevPosition.y-t.y),this.camera.update(),this.render()}else if(this.mouseState.button===h.default.MOUSE_BUTTON_RIGHT){var r=t.sub(this.mouseState.prevPosition),i=this.camera.getFocalXYVector(this.canvas.width,this.canvas.height),s=a(i,2),o=s[0],c=s[1];this.camera.target=this.camera.prevTarget.add(o.scale(-r.x).add(c.scale(-r.y)).scale(.005)),this.camera.update(),this.render()}}}}]),t}(h.default);t.default=x},function(e,t,n){"use strict";function r(e){return e&&e.__esModule?e:{default:e}}function i(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}Object.defineProperty(t,"__esModule",{value:!0});var s=function(){function e(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}return function(t,n,r){return n&&e(t.prototype,n),r&&e(t,r),t}}(),o=n(14),a=r(o),c=n(1),u=r(c),h=n(0),f=r(h),l=function(){function e(t,n){i(this,e),this.zb=t,this.zc=n,this.updateListeners=[],this.update(),this.selectedComponentId=-1,this.pointRadius=.02,this.lineWidth=.01}return s(e,[{key:"addUpdateListener",value:function(e){this.updateListeners.push(e)}},{key:"updated",value:function(){var e=!0,t=!1,n=void 0;try{for(var r,i=this.updateListeners[Symbol.iterator]();!(e=(r=i.next()).done);e=!0){(0,r.value)()}}catch(e){t=!0,n=e}finally{try{!e&&i.return&&i.return()}finally{if(t)throw n}}}},{key:"update",value:function(){this.computeSpheres(),this.inversionSphere=new a.default(-this.s6.center.x,-this.s6.center.y,this.s6.center.z,this.s6.r),this.computeInvSpheres(),this.computeVertexes(),this.computeSeedSpheres(),this.updated()}},{key:"computeSpheres",value:function(){var e=.5+this.zb*this.zc/3,t=.5+(this.zb*this.zb-this.zb*this.zc)/3,n=.5+(-this.zb*this.zc+this.zc*this.zc)/3;this.s2=new a.default(1-e,0,0,e),this.s4=new a.default(.5*-(1-t),this.zb,Math.sqrt(3)*(1-t)*.5,t),this.s6=new a.default(.5*-(1-n),this.zc,-Math.sqrt(3)*(1-n)*.5,n)}},{key:"computeInvSpheres",value:function(){var e=1/Math.sqrt(3);this.s1inv=this.inversionSphere.invertOnPlane(new u.default(0,5,e),new u.default(1,1,0),new u.default(2,2,-e)),this.s2inv=this.inversionSphere.invertOnSphere(this.s2),this.s3inv=this.inversionSphere.invertOnPlane(new u.default(0,3,-e),new u.default(1,3,0),new u.default(2,2,e)),this.s4inv=this.inversionSphere.invertOnSphere(this.s4),this.s5inv=this.inversionSphere.invertOnPlane(new u.default(-.5,0,1),new u.default(-.5,1,0),new u.default(-.5,2,1)),this.s6inv=this.inversionSphere.invertOnSphere(this.s6)}},{key:"setUniformLocations",value:function(e,t,n){t.push(e.getUniformLocation(n,"u_zbzc")),t.push(e.getUniformLocation(n,"u_ui")),t.push(e.getUniformLocation(n,"u_iniSpheres[0].center")),t.push(e.getUniformLocation(n,"u_iniSpheres[0].r")),t.push(e.getUniformLocation(n,"u_iniSpheres[1].center")),t.push(e.getUniformLocation(n,"u_iniSpheres[1].r")),t.push(e.getUniformLocation(n,"u_iniSpheres[2].center")),t.push(e.getUniformLocation(n,"u_iniSpheres[2].r")),t.push(e.getUniformLocation(n,"u_inversionSphere.center")),t.push(e.getUniformLocation(n,"u_inversionSphere.r")),t.push(e.getUniformLocation(n,"u_convexSphere.center")),t.push(e.getUniformLocation(n,"u_convexSphere.r")),t.push(e.getUniformLocation(n,"u_spheirahedraSpheres[0].center")),t.push(e.getUniformLocation(n,"u_spheirahedraSpheres[0].r")),t.push(e.getUniformLocation(n,"u_spheirahedraSpheres[1].center")),t.push(e.getUniformLocation(n,"u_spheirahedraSpheres[1].r")),t.push(e.getUniformLocation(n,"u_spheirahedraSpheres[2].center")),t.push(e.getUniformLocation(n,"u_spheirahedraSpheres[2].r")),t.push(e.getUniformLocation(n,"u_spheirahedraSpheres[3].center")),t.push(e.getUniformLocation(n,"u_spheirahedraSpheres[3].r")),t.push(e.getUniformLocation(n,"u_spheirahedraSpheres[4].center")),t.push(e.getUniformLocation(n,"u_spheirahedraSpheres[4].r")),t.push(e.getUniformLocation(n,"u_spheirahedraSpheres[5].center")),t.push(e.getUniformLocation(n,"u_spheirahedraSpheres[5].r")),t.push(e.getUniformLocation(n,"u_seedSpheres[0].center")),t.push(e.getUniformLocation(n,"u_seedSpheres[0].r")),t.push(e.getUniformLocation(n,"u_seedSpheres[1].center")),t.push(e.getUniformLocation(n,"u_seedSpheres[1].r")),t.push(e.getUniformLocation(n,"u_seedSpheres[2].center")),t.push(e.getUniformLocation(n,"u_seedSpheres[2].r")),t.push(e.getUniformLocation(n,"u_seedSpheres[3].center")),t.push(e.getUniformLocation(n,"u_seedSpheres[3].r")),t.push(e.getUniformLocation(n,"u_seedSpheres[4].center")),t.push(e.getUniformLocation(n,"u_seedSpheres[4].r")),t.push(e.getUniformLocation(n,"u_seedSpheres[5].center")),t.push(e.getUniformLocation(n,"u_seedSpheres[5].r")),t.push(e.getUniformLocation(n,"u_seedSpheres[6].center")),t.push(e.getUniformLocation(n,"u_seedSpheres[6].r")),t.push(e.getUniformLocation(n,"u_seedSpheres[7].center")),t.push(e.getUniformLocation(n,"u_seedSpheres[7].r"))}},{key:"setUniformValues",value:function(e,t,n,r){e.uniform2f(t[n++],this.zb,this.zc),e.uniform2f(t[n++],this.pointRadius*r,this.lineWidth*r),e.uniform3f(t[n++],this.s2.center.x,this.s2.center.y,this.s2.center.z),e.uniform2f(t[n++],this.s2.r,this.s2.rSq),e.uniform3f(t[n++],this.s4.center.x,this.s4.center.y,this.s4.center.z),e.uniform2f(t[n++],this.s4.r,this.s4.rSq),e.uniform3f(t[n++],this.s6.center.x,this.s6.center.y,this.s6.center.z),e.uniform2f(t[n++],this.s6.r,this.s6.rSq),e.uniform3f(t[n++],this.inversionSphere.center.x,this.inversionSphere.center.y,this.inversionSphere.center.z),e.uniform2f(t[n++],this.inversionSphere.r,this.inversionSphere.rSq),e.uniform3f(t[n++],this.convexSphere.center.x,this.convexSphere.center.y,this.convexSphere.center.z),e.uniform2f(t[n++],this.convexSphere.r,this.convexSphere.rSq),e.uniform3f(t[n++],this.s1inv.center.x,this.s1inv.center.y,this.s1inv.center.z),e.uniform2f(t[n++],this.s1inv.r,this.s1inv.rSq),e.uniform3f(t[n++],this.s2inv.center.x,this.s2inv.center.y,this.s2inv.center.z),e.uniform2f(t[n++],this.s2inv.r,this.s2inv.rSq),e.uniform3f(t[n++],this.s3inv.center.x,this.s3inv.center.y,this.s3inv.center.z),e.uniform2f(t[n++],this.s3inv.r,this.s3inv.rSq),e.uniform3f(t[n++],this.s4inv.center.x,this.s4inv.center.y,this.s4inv.center.z),e.uniform2f(t[n++],this.s4inv.r,this.s4inv.rSq),e.uniform3f(t[n++],this.s5inv.center.x,this.s5inv.center.y,this.s5inv.center.z),e.uniform2f(t[n++],this.s5inv.r,this.s5inv.rSq),e.uniform3f(t[n++],this.s6inv.center.x,this.s6inv.center.y,this.s6inv.center.z),e.uniform2f(t[n++],this.s6inv.r,this.s6inv.rSq);for(var i=0;i<8;i++)e.uniform3f(t[n++],this.seedSpheres[i].center.x,this.seedSpheres[i].center.y,this.seedSpheres[i].center.z),e.uniform2f(t[n++],this.seedSpheres[i].r,this.seedSpheres[i].rSq);return n}},{key:"computeSeedSphere",value:function(e,t,n,r,i){var s=r.center.sub(n.center),o=i.center.sub(n.center),c=u.default.cross(s,o),h=t.sub(e).lengthSq()/(2*u.default.dot(t.sub(e),c)),f=e.add(c.scale(h));return new a.default(f.x,f.y,f.z,Math.abs(h)*c.length())}},{key:"computeMinSeedSphere",value:function(e,t,n,r,i){var s=new a.default(0,0,0,99999999999),o=!0,c=!1,h=void 0;try{for(var f,l=t[Symbol.iterator]();!(o=(f=l.next()).done);o=!0){var d=f.value;if(!(u.default.distance(e,d)<1e-6)){var p=this.computeSeedSphere(e,d,n,r,i);p.r<s.r&&(s=p)}}}catch(e){c=!0,h=e}finally{try{!o&&l.return&&l.return()}finally{if(c)throw h}}return s}},{key:"addSphereIfNotExists",value:function(e,t){var n=!0,r=!1,i=void 0;try{for(var s,o=e[Symbol.iterator]();!(n=(s=o.next()).done);n=!0){var a=s.value;if(Math.abs(a.r,t.r)<1e-5&&u.default.distance(a.center,t.center)<1e-5)return void console.log("duplicate")}}catch(e){r=!0,i=e}finally{try{!n&&o.return&&o.return()}finally{if(r)throw i}}e.push(t)}},{key:"computeSeedSpheres",value:function(){this.seedSpheres=[],this.addSphereIfNotExists(this.seedSpheres,this.computeMinSeedSphere(this.vertexes[0],this.vertexes,this.s1inv,this.s2inv,this.s3inv)),this.addSphereIfNotExists(this.seedSpheres,this.computeMinSeedSphere(this.vertexes[1],this.vertexes,this.s1inv,this.s4inv,this.s5inv)),this.addSphereIfNotExists(this.seedSpheres,this.computeMinSeedSphere(this.vertexes[2],this.vertexes,this.s3inv,this.s5inv,this.s6inv)),this.addSphereIfNotExists(this.seedSpheres,this.computeMinSeedSphere(this.vertexes[3],this.vertexes,this.s1inv,this.s2inv,this.s4inv)),this.addSphereIfNotExists(this.seedSpheres,this.computeMinSeedSphere(this.vertexes[4],this.vertexes,this.s4inv,this.s5inv,this.s6inv)),this.addSphereIfNotExists(this.seedSpheres,this.computeMinSeedSphere(this.vertexes[5],this.vertexes,this.s2inv,this.s3inv,this.s6inv)),this.addSphereIfNotExists(this.seedSpheres,this.computeMinSeedSphere(this.vertexes[6],this.vertexes,this.s2inv,this.s4inv,this.s6inv)),this.addSphereIfNotExists(this.seedSpheres,this.computeMinSeedSphere(this.vertexes[7],this.vertexes,this.s1inv,this.s3inv,this.s5inv)),this.convexSphere=a.default.fromPoints(this.vertexes[0],this.vertexes[2],this.vertexes[4],this.vertexes[7])}},{key:"computeVertexes",value:function(){this.vertexes=[],this.vertexes.push(this.computeIdealVertex(this.s1inv,this.s2inv,this.s3inv)),this.vertexes.push(this.computeIdealVertex(this.s1inv,this.s4inv,this.s5inv)),this.vertexes.push(this.computeIdealVertex(this.s3inv,this.s5inv,this.s6inv)),this.vertexes.push(this.computeIdealVertex(this.s1inv,this.s2inv,this.s4inv)),this.vertexes.push(this.computeIdealVertex(this.s4inv,this.s5inv,this.s6inv)),this.vertexes.push(this.computeIdealVertex(this.s2inv,this.s3inv,this.s6inv)),this.vertexes.push(this.computeIdealVertex(this.s2inv,this.s4inv,this.s6inv)),this.vertexes.push(this.computeIdealVertex(this.s1inv,this.s3inv,this.s5inv))}},{key:"computeIdealVertex",value:function(e,t,n){var r=.5*(e.center.lengthSq()-t.center.lengthSq()-e.rSq+t.rSq)-e.center.lengthSq()+u.default.dot(e.center,t.center),i=.5*(e.center.lengthSq()-n.center.lengthSq()-e.rSq+n.rSq)-e.center.lengthSq()+u.default.dot(e.center,n.center),s=-e.center.lengthSq()-t.center.lengthSq()+2*u.default.dot(e.center,t.center),o=-e.center.lengthSq()-n.center.lengthSq()+2*u.default.dot(e.center,n.center),a=-e.center.lengthSq()+u.default.dot(e.center,t.center)+u.default.dot(e.center,n.center)-u.default.dot(t.center,n.center),c=(r*o-i*a)/(s*o-a*a),h=(i*s-r*a)/(s*o-a*a);return e.center.add(t.center.sub(e.center).scale(c)).add(n.center.sub(e.center).scale(h))}},{key:"select",value:function(t,n){var r=new f.default(this.zb,this.zc);if(f.default.distance(t,new f.default(this.zb,this.zc))<.1)return this.selectedComponentId=e.POINT_ZB_ZC,void(this.diffToComponent=t.sub(r));this.selectedComponentId=-1}},{key:"move",value:function(t){if(this.selectedComponentId===e.POINT_ZB_ZC){var n=t.sub(this.diffToComponent);return this.zb=n.x,this.zc=n.y,this.update(),!0}return!1}}],[{key:"POINT_ZB_ZC",get:function(){return 0}}]),e}();t.default=l},function(e,t){e.exports="#version 300 es\n\nprecision mediump float;\n\nstruct Camera {\n    vec3 pos;\n    vec3 target;\n    float fov;\n    vec3 up;\n};\n\nstruct Sphere {\n    vec3 center;\n    vec2 r;\n};\n\nuniform vec2 u_resolution;\nuniform Camera u_camera;\nuniform Sphere u_iniSpheres[3];\nuniform Sphere u_inversionSphere;\nuniform Sphere u_spheirahedraSpheres[6];\nuniform Sphere u_seedSpheres[8];\n\nvec3 calcRay (const vec3 eye, const vec3 target, const vec3 up, const float fov,\n              const vec2 resolution, const vec2 coord){\n    float imagePlane = (resolution.y * .5) / tan(fov * .5);\n    vec3 v = normalize(target - eye);\n    vec3 xaxis = normalize(cross(v, up));\n    vec3 yaxis =  normalize(cross(v, xaxis));\n    vec3 center = v * imagePlane;\n    vec3 origin = center - (xaxis * (resolution.x  *.5)) - (yaxis * (resolution.y * .5));\n    return normalize(origin + (xaxis * coord.x) + (yaxis * (resolution.y - coord.y)));\n}\n\nconst float DISPLAY_GAMMA_COEFF = 1. / 2.2;\nvec4 gammaCorrect(vec4 rgba) {\n    return vec4((min(pow(rgba.r, DISPLAY_GAMMA_COEFF), 1.)),\n                (min(pow(rgba.g, DISPLAY_GAMMA_COEFF), 1.)),\n                (min(pow(rgba.b, DISPLAY_GAMMA_COEFF), 1.)),\n                rgba.a);\n}\n\n\nvec3 hsv2rgb(float h, float s, float v){\n    vec3 c = vec3(h, s, v);\n    const vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n// front to back blend\nvec4 blendCol(vec4 srcC, vec4 outC){\n\tsrcC.rgb *= srcC.a;\n\treturn outC + srcC * (1.0 - outC.a);\n}\n\nstruct IsectInfo {\n    int objId;\n    int objIndex;\n    int objComponentId;\n    vec3 normal;\n    vec3 intersection;\n    float mint;\n    float maxt;\n    vec3 matColor;\n    bool hit;\n};\n\nfloat MAX_FLOAT = 1e20;\nconst float THRESHOLD = 0.001;\n\nIsectInfo newIsectInfo() {\n    IsectInfo isectInfo;\n    isectInfo.objId = -1;\n    isectInfo.objIndex = -1;\n    isectInfo.objComponentId = -1;\n    isectInfo.mint = MAX_FLOAT;\n    isectInfo.maxt = 9999999.;\n    isectInfo.hit = false;\n    return isectInfo;\n}\n\nbool intersectBBox(vec3 rayOrg, vec3 rayDir, vec3 boxMin, vec3 boxMax,\n                  out float hit0, out float hit1, out bool inBox) {\n\tfloat t0 = -1000000.0, t1 = 1000000.0;\n    hit0 = t0;\n    hit1 = t1;\n    inBox = false;\n    vec3 tNear = (boxMin - rayOrg) / rayDir;\n    vec3 tFar  = (boxMax - rayOrg) / rayDir;\n\n    if (tNear.x > tFar.x) {\n        float tmp = tNear.x;\n        tNear.x = tFar.x;\n        tFar.x = tmp;\n    }\n\n    t0 = max(tNear.x, t0);\n    t1 = min(tFar.x, t1);\n\n\n    if (tNear.y > tFar.y) {\n        float tmp = tNear.y;\n        tNear.y = tFar.y;\n        tFar.y = tmp;\n    }\n    t0 = max(tNear.y, t0);\n    t1 = min(tFar.y, t1);\n\n    if (tNear.z > tFar.z) {\n        float tmp = tNear.z;\n        tNear.z = tFar.z;\n        tFar.z = tmp;\n    }\n    t0 = max(tNear.z, t0);\n    t1 = min(tFar.z, t1);\n\n    if (t0 <= t1 && 0. < t1) {\n        if(t0 < 0.) inBox = true;\n        hit0 = t0;\n        hit1 = t1;\n        return true;\n    }\n    return false;\n}\n\nvoid sphereInvert(inout vec3 pos, inout float dr, vec3 center, vec2 r) {\n    vec3 diff = pos - center;\n    float lenSq = dot(diff, diff);\n    dr *= r.y / lenSq; // (r * r) / lenSq\n    pos = (diff * r.y) / lenSq + center;\n}\n\nvec2 rand2n(const vec2 co, const float sampleIndex) {\n    vec2 seed = co * (sampleIndex + 1.0);\n    seed+=vec2(-1,1);\n    // implementation based on: lumina.sourceforge.net/Tutorials/Noise.html\n    return vec2(fract(sin(dot(seed.xy ,vec2(12.9898,78.233))) * 43758.5453),\n                fract(cos(dot(seed.xy ,vec2(4.898,7.23))) * 23421.631));\n}\n\nvec4 distUnion(vec4 t1, vec4 t2) {\n    return (t1.x < t2.x) ? t1 : t2;\n}\n\nfloat distPlane(const vec3 pos, const vec3 p, const vec3 normal) {\n    return dot(pos - p, normal);\n}\n\nconst int ID_PRISM = 0;\n\nfloat distPrism(const vec3 pos) {\n    float d = distPlane(pos, vec3(1, 0 ,0), normalize(vec3(sqrt(3.) * .5, 0., 1.5)));\n    d = max(distPlane(pos, vec3(1, 0 ,0), normalize(vec3(sqrt(3.) * .5, 0., -1.5))), d);\n    d = max(distPlane(pos, vec3(-0.5, 0 ,0), normalize(vec3(-1, 0, 0))), d);\n    return d;\n}\n\nfloat distSphere(const vec3 pos, const Sphere sphere, vec3 offset) {\n    return distance(pos, sphere.center + offset) - sphere.r.x;\n}\n\nfloat distInfSpheirahedra(const vec3 pos) {\n    float d = distPrism(pos);\n    d = max(-distSphere(pos, u_iniSpheres[0], vec3(0)), d);\n    d = max(-distSphere(pos, u_iniSpheres[1], vec3(0)), d);\n    d = max(-distSphere(pos, u_iniSpheres[2], vec3(0)), d);\n    return d;\n}\n\nfloat distSpheirahedra(vec3 pos) {\n    Sphere s;\n    s.center = u_inversionSphere.center;\n    s.r.x = u_inversionSphere.r.x * 1.2;\n    float d = distSphere(pos, s, -u_inversionSphere.center);\n    d = max(-distSphere(pos, u_spheirahedraSpheres[0], -u_inversionSphere.center), d);\n    d = max(-distSphere(pos, u_spheirahedraSpheres[1], -u_inversionSphere.center), d);\n    d = max(-distSphere(pos, u_spheirahedraSpheres[2], -u_inversionSphere.center), d);\n    d = max(-distSphere(pos, u_spheirahedraSpheres[3], -u_inversionSphere.center), d);\n    d = max(-distSphere(pos, u_spheirahedraSpheres[4], -u_inversionSphere.center), d);\n    d = max(-distSphere(pos, u_spheirahedraSpheres[5], -u_inversionSphere.center), d);\n    return d;\n}\n\nfloat g_invNum;\nfloat distLimitset(vec3 pos) {\n    pos += u_seedSpheres[3].center;\n    float dr = 1.;\n    float invNum = 0.;\n    for(int i = 0; i < 100; i++) {\n        bool inFund = true;\n        if(distance(pos, u_spheirahedraSpheres[0].center) < u_spheirahedraSpheres[0].r.x) {\n            invNum++;\n            sphereInvert(pos, dr,\n                         u_spheirahedraSpheres[0].center,\n                         u_spheirahedraSpheres[0].r);\n            inFund = false;\n        }\n        if(distance(pos, u_spheirahedraSpheres[1].center) < u_spheirahedraSpheres[1].r.x) {\n            invNum++;\n            sphereInvert(pos, dr,\n                         u_spheirahedraSpheres[1].center,\n                         u_spheirahedraSpheres[1].r);\n            inFund = false;\n        }\n        if(distance(pos, u_spheirahedraSpheres[2].center) < u_spheirahedraSpheres[2].r.x) {\n            invNum++;\n            sphereInvert(pos, dr,\n                         u_spheirahedraSpheres[2].center,\n                         u_spheirahedraSpheres[2].r);\n            inFund = false;\n        }\n        if(distance(pos, u_spheirahedraSpheres[3].center) < u_spheirahedraSpheres[3].r.x) {\n            invNum++;\n            sphereInvert(pos, dr,\n                         u_spheirahedraSpheres[3].center,\n                         u_spheirahedraSpheres[3].r);\n            inFund = false;\n        }\n        if(distance(pos, u_spheirahedraSpheres[4].center) < u_spheirahedraSpheres[4].r.x) {\n            invNum++;\n            sphereInvert(pos, dr,\n                         u_spheirahedraSpheres[4].center,\n                         u_spheirahedraSpheres[4].r);\n            inFund = false;\n        }\n        if(distance(pos, u_spheirahedraSpheres[5].center) < u_spheirahedraSpheres[5].r.x) {\n            invNum++;\n            sphereInvert(pos, dr,\n                         u_spheirahedraSpheres[5].center,\n                         u_spheirahedraSpheres[5].r);\n            inFund = false;\n        }\n        if(inFund) break;\n    }\n    g_invNum = invNum;\n    float minDist = 9999999.;\n    for(int i = 0; i < 8; i++) {\n        minDist = min(minDist,\n                      (distance(pos, u_seedSpheres[i].center) - u_seedSpheres[i].r.x) / abs(dr) * 0.2);\n    }\n    return minDist;\n    //    return (distance(pos, u_inversionSphere.center) - u_inversionSphere.r.x * .1) / dr * 0.05;\n}\n\nvec4 distFunc(const vec3 pos) {\n    vec4 hit = vec4(MAX_FLOAT, -1, -1, -1);\n    hit = distUnion(hit, vec4(distLimitset(pos), ID_PRISM, -1, -1));\n    return hit;\n}\n\nconst vec2 NORMAL_COEFF = vec2(0.001, 0.);\nvec3 computeNormal(const vec3 p) {\n    return normalize(vec3(distFunc(p + NORMAL_COEFF.xyy).x - distFunc(p - NORMAL_COEFF.xyy).x,\n                          distFunc(p + NORMAL_COEFF.yxy).x - distFunc(p - NORMAL_COEFF.yxy).x,\n                          distFunc(p + NORMAL_COEFF.yyx).x - distFunc(p - NORMAL_COEFF.yyx).x));\n}\n\nconst int MAX_MARCHING_LOOP = 1000;\nconst float MARCHING_THRESHOLD = 0.00001;\nvoid march(const vec3 rayOrg, const vec3 rayDir, inout IsectInfo isectInfo) {\n    float rayLength = 0.;\n    vec3 rayPos = rayOrg + rayDir * rayLength;\n    vec4 dist = vec4(-1);\n    for(int i = 0 ; i < MAX_MARCHING_LOOP ; i++) {\n        if(rayLength > isectInfo.maxt ||\n           rayLength > isectInfo.mint) break;\n        dist = distFunc(rayPos);\n        rayLength += dist.x;\n        rayPos = rayOrg + rayDir * rayLength;\n        if(dist.x < MARCHING_THRESHOLD) {\n            isectInfo.objId = int(dist.y);\n            //isectInfo.objIndex = int(dist.z);\n            //isectInfo.objComponentId = int(dist.w);\n            isectInfo.matColor = hsv2rgb(-0.13 + (g_invNum ) * 0.01, 1., 1.);\n            //     hsv2rgb(0.33, 1., .77) :\n            //     hsv2rgb(0.0 + g_invNum * 0.12 , 1., 1.);\n            isectInfo.intersection = rayPos;\n            isectInfo.normal = computeNormal(rayPos);\n            isectInfo.hit = true;\n            break;\n        }\n    }\n}\n\nconst vec3 AMBIENT_FACTOR = vec3(0.1);\nconst vec3 LIGHT_DIR = normalize(vec3(0, 1, 1));\nvec3 computeColor(const vec3 rayOrg, const vec3 rayDir) {\n    IsectInfo isectInfo = newIsectInfo();\n    vec3 rayPos = rayOrg;\n\n    vec3 l = vec3(0);\n\n    march(rayPos, rayDir, isectInfo);\n    if(isectInfo.hit) {\n        vec3 matColor = isectInfo.matColor;\n        vec3 diffuse =  clamp(dot(isectInfo.normal, LIGHT_DIR), 0., 1.) * matColor;\n        vec3 ambient = matColor * AMBIENT_FACTOR;\n        l += (diffuse) + ambient;\n    }\n\n    return l;\n}\n\nout vec4 outColor;\nvoid main() {\n    vec3 sum = vec3(0);\n    float MAX_SAMPLES = 1.;\n    for (float i = 0. ; i < MAX_SAMPLES ; i++) {\n        vec2 coordOffset = rand2n(gl_FragCoord.xy, i);\n        vec3 ray = calcRay(u_camera.pos, u_camera.target, u_camera.up, u_camera.fov,\n                           u_resolution, gl_FragCoord.xy + coordOffset);\n        sum += computeColor(u_camera.pos, ray);\n    }\n    outColor = gammaCorrect(vec4(sum / MAX_SAMPLES, 1.0));\n}\n"},function(e,t){e.exports="#version 300 es\n\nprecision mediump float;\n\nstruct Sphere {\n    vec3 center;\n    vec2 r;\n};\n\nuniform vec2 u_resolution;\nuniform vec3 u_geometry;\nuniform vec2 u_zbzc; //[zb, zc]\nuniform vec2 u_ui; //[pointRadius, lineWidth]\nuniform Sphere u_iniSpheres[3];\nuniform Sphere u_inversionSphere;\nuniform Sphere u_spheirahedraSpheres[6];\n\nconst float DISPLAY_GAMMA_COEFF = 1. / 2.2;\nvec4 gammaCorrect(vec4 rgba) {\n    return vec4((min(pow(rgba.r, DISPLAY_GAMMA_COEFF), 1.)),\n                (min(pow(rgba.g, DISPLAY_GAMMA_COEFF), 1.)),\n                (min(pow(rgba.b, DISPLAY_GAMMA_COEFF), 1.)),\n                rgba.a);\n}\n\nvec2 rand2n(const vec2 co, const float sampleIndex) {\n    vec2 seed = co * (sampleIndex + 1.0);\n    seed+=vec2(-1,1);\n    // implementation based on: lumina.sourceforge.net/Tutorials/Noise.html\n    return vec2(fract(sin(dot(seed.xy ,vec2(12.9898,78.233))) * 43758.5453),\n                fract(cos(dot(seed.xy ,vec2(4.898,7.23))) * 23421.631));\n}\n\nout vec4 outColor;\nconst float MAX_SAMPLES = 20.;\nvoid main() {\n    vec3 sum = vec3(0);\n    float ratio = u_resolution.x / u_resolution.y / 2.0;\n    for(float i = 0.; i < MAX_SAMPLES; i++){\n        vec2 position = ((gl_FragCoord.xy + rand2n(gl_FragCoord.xy, i)) / u_resolution.yy ) - vec2(ratio, 0.5);\n        position = position * u_geometry.z;\n        position += u_geometry.xy;\n\n        if (distance(position, u_zbzc) < u_ui.x) {\n            // point (zb, zc)\n            sum += vec3(1, 0, 0);\n        } else if (abs(position.x * position.y - (3. / 4.)) < u_ui.y) {\n            // zb * zc = 3/4\n            sum += vec3(0, 1, 0);\n        } else if (abs(position.x * position.x - position.x * position.y - (3. / 4.)) < u_ui.y) {\n            // zc^2 - zb * zc = 3/4\n            sum += vec3(0, 1, 0);\n        } else if (abs(position.y * position.y - position.x * position.y - (3. / 4.)) < u_ui.y) {\n            // zb^2 - zb * zc = 3/4\n            sum += vec3(0, 1, 0);\n        } else if (abs(position.y - position.x * 2.) < u_ui.y) {\n            // zc = 2 * zb\n            sum += vec3(0, 0, 1);\n        } else if (abs(position.x) < u_ui.y ||\n                   abs(position.y) < u_ui.y) {\n            // z-axis and y-axis\n            sum += vec3(0.7);\n        } else if(position.x > 0. && position.y > 0. &&\n                  position.y > position.x * 2. &&\n                  (position.y * position.y - position.x * position.y - (3. / 4.)) < 0.) {\n            sum += vec3(0.3, 0.3, 0.);\n        }\n    }\n\n    outColor = gammaCorrect(vec4(sum / MAX_SAMPLES, 1));\n}\n"},function(e,t){e.exports="#version 300 es\n\nprecision mediump float;\n\nstruct Camera {\n    vec3 pos;\n    vec3 target;\n    float fov;\n    vec3 up;\n};\n\nstruct Sphere {\n    vec3 center;\n    vec2 r;\n};\n\nuniform vec2 u_resolution;\nuniform Camera u_camera;\nuniform Sphere u_iniSpheres[3];\nuniform Sphere u_inversionSphere;\nuniform Sphere u_spheirahedraSpheres[6];\n\nvec3 calcRay (const vec3 eye, const vec3 target, const vec3 up, const float fov,\n              const vec2 resolution, const vec2 coord){\n    float imagePlane = (resolution.y * .5) / tan(fov * .5);\n    vec3 v = normalize(target - eye);\n    vec3 xaxis = normalize(cross(v, up));\n    vec3 yaxis =  normalize(cross(v, xaxis));\n    vec3 center = v * imagePlane;\n    vec3 origin = center - (xaxis * (resolution.x  *.5)) - (yaxis * (resolution.y * .5));\n    return normalize(origin + (xaxis * coord.x) + (yaxis * (resolution.y - coord.y)));\n}\n\nconst float DISPLAY_GAMMA_COEFF = 1. / 2.2;\nvec4 gammaCorrect(vec4 rgba) {\n    return vec4((min(pow(rgba.r, DISPLAY_GAMMA_COEFF), 1.)),\n                (min(pow(rgba.g, DISPLAY_GAMMA_COEFF), 1.)),\n                (min(pow(rgba.b, DISPLAY_GAMMA_COEFF), 1.)),\n                rgba.a);\n}\n\nstruct IsectInfo {\n    int objId;\n    int objIndex;\n    int objComponentId;\n    vec3 normal;\n    vec3 intersection;\n    float mint;\n    float maxt;\n    vec3 matColor;\n    bool hit;\n};\n\nfloat MAX_FLOAT = 1e20;\nconst float THRESHOLD = 0.001;\n\nIsectInfo newIsectInfo() {\n    IsectInfo isectInfo;\n    isectInfo.objId = -1;\n    isectInfo.objIndex = -1;\n    isectInfo.objComponentId = -1;\n    isectInfo.mint = MAX_FLOAT;\n    isectInfo.maxt = 9999999.;\n    isectInfo.hit = false;\n    return isectInfo;\n}\n\nbool intersectBBox(vec3 rayOrg, vec3 rayDir, vec3 boxMin, vec3 boxMax,\n                  out float hit0, out float hit1, out bool inBox) {\n\tfloat t0 = -1000000.0, t1 = 1000000.0;\n    hit0 = t0;\n    hit1 = t1;\n    inBox = false;\n    vec3 tNear = (boxMin - rayOrg) / rayDir;\n    vec3 tFar  = (boxMax - rayOrg) / rayDir;\n\n    if (tNear.x > tFar.x) {\n        float tmp = tNear.x;\n        tNear.x = tFar.x;\n        tFar.x = tmp;\n    }\n\n    t0 = max(tNear.x, t0);\n    t1 = min(tFar.x, t1);\n\n\n    if (tNear.y > tFar.y) {\n        float tmp = tNear.y;\n        tNear.y = tFar.y;\n        tFar.y = tmp;\n    }\n    t0 = max(tNear.y, t0);\n    t1 = min(tFar.y, t1);\n\n    if (tNear.z > tFar.z) {\n        float tmp = tNear.z;\n        tNear.z = tFar.z;\n        tFar.z = tmp;\n    }\n    t0 = max(tNear.z, t0);\n    t1 = min(tFar.z, t1);\n\n    if (t0 <= t1 && 0. < t1) {\n        if(t0 < 0.) inBox = true;\n        hit0 = t0;\n        hit1 = t1;\n        return true;\n    }\n    return false;\n}\n\nvec2 rand2n(const vec2 co, const float sampleIndex) {\n    vec2 seed = co * (sampleIndex + 1.0);\n    seed+=vec2(-1,1);\n    // implementation based on: lumina.sourceforge.net/Tutorials/Noise.html\n    return vec2(fract(sin(dot(seed.xy ,vec2(12.9898,78.233))) * 43758.5453),\n                fract(cos(dot(seed.xy ,vec2(4.898,7.23))) * 23421.631));\n}\n\nvec4 distUnion(vec4 t1, vec4 t2) {\n    return (t1.x < t2.x) ? t1 : t2;\n}\n\nfloat distPlane(const vec3 pos, const vec3 p, const vec3 normal) {\n    return dot(pos - p, normal);\n}\n\nconst int ID_PRISM = 0;\n\nfloat distPrism(const vec3 pos) {\n    float d = distPlane(pos, vec3(1, 0 ,0), normalize(vec3(sqrt(3.) * .5, 0., 1.5)));\n    d = max(distPlane(pos, vec3(1, 0 ,0), normalize(vec3(sqrt(3.) * .5, 0., -1.5))), d);\n    d = max(distPlane(pos, vec3(-0.5, 0 ,0), normalize(vec3(-1, 0, 0))), d);\n    return d;\n}\n\nfloat distSphere(const vec3 pos, const Sphere sphere) {\n    return distance(pos, sphere.center) - sphere.r.x;\n}\n\nfloat distInfSpheirahedra(const vec3 pos) {\n    float d = distPrism(pos);\n    d = max(-distSphere(pos, u_iniSpheres[0]), d);\n    d = max(-distSphere(pos, u_iniSpheres[1]), d);\n    d = max(-distSphere(pos, u_iniSpheres[2]), d);\n    return d;\n}\n\nvec4 distFunc(const vec3 pos) {\n    vec4 hit = vec4(MAX_FLOAT, -1, -1, -1);\n    hit = distUnion(hit, vec4(distInfSpheirahedra(pos), ID_PRISM, -1, -1));\n    return hit;\n}\n\nconst vec2 NORMAL_COEFF = vec2(0.005, 0.);\nvec3 computeNormal(const vec3 p) {\n    return normalize(vec3(distFunc(p + NORMAL_COEFF.xyy).x - distFunc(p - NORMAL_COEFF.xyy).x,\n                          distFunc(p + NORMAL_COEFF.yxy).x - distFunc(p - NORMAL_COEFF.yxy).x,\n                          distFunc(p + NORMAL_COEFF.yyx).x - distFunc(p - NORMAL_COEFF.yyx).x));\n}\n\nconst int MAX_MARCHING_LOOP = 2000;\nconst float MARCHING_THRESHOLD = 0.01;\nvoid march(const vec3 rayOrg, const vec3 rayDir, inout IsectInfo isectInfo) {\n    float rayLength = 0.;\n    vec3 rayPos = rayOrg + rayDir * rayLength;\n    vec4 dist = vec4(-1);\n    for(int i = 0 ; i < MAX_MARCHING_LOOP ; i++) {\n        if(rayLength > isectInfo.maxt ||\n           rayLength > isectInfo.mint) break;\n        dist = distFunc(rayPos);\n        rayLength += dist.x;\n        rayPos = rayOrg + rayDir * rayLength;\n        if(dist.x < MARCHING_THRESHOLD) {\n            isectInfo.objId = int(dist.y);\n            //isectInfo.objIndex = int(dist.z);\n            //isectInfo.objComponentId = int(dist.w);\n            // isectInfo.matColor = (g_invNum == 0.) ?\n            //     hsv2rgb(0.33, 1., .77) :\n            //     hsv2rgb(0.0 + g_invNum * 0.12 , 1., 1.);\n            isectInfo.intersection = rayPos;\n            isectInfo.normal = computeNormal(rayPos);\n            isectInfo.hit = true;\n            break;\n        }\n    }\n}\n\nconst vec3 AMBIENT_FACTOR = vec3(0.1);\nconst vec3 LIGHT_DIR = normalize(vec3(1, 1, 0));\nvec3 computeColor(const vec3 rayOrg, const vec3 rayDir) {\n    IsectInfo isectInfo = newIsectInfo();\n    vec3 rayPos = rayOrg;\n\n    vec3 l = vec3(0);\n\n    march(rayPos, rayDir, isectInfo);\n    if(isectInfo.hit) {\n        vec3 matColor = vec3(1);\n        vec3 diffuse =  clamp(dot(isectInfo.normal, LIGHT_DIR), 0., 1.) * matColor;\n        vec3 ambient = matColor * AMBIENT_FACTOR;\n        l += (diffuse) + ambient;\n    }\n\n    return l;\n}\n\nout vec4 outColor;\nvoid main() {\n    vec2 coordOffset = rand2n(gl_FragCoord.xy, 0.);\n    vec3 ray = calcRay(u_camera.pos, u_camera.target, u_camera.up, u_camera.fov,\n                       u_resolution, gl_FragCoord.xy + coordOffset);\n    outColor = gammaCorrect(vec4(computeColor(u_camera.pos, ray), 1.0));\n}\n"},function(e,t){e.exports="#version 300 es\n\nprecision mediump float;\n\nstruct Camera {\n    vec3 pos;\n    vec3 target;\n    float fov;\n    vec3 up;\n};\n\nstruct Sphere {\n    vec3 center;\n    vec2 r;\n};\n\nuniform vec2 u_resolution;\nuniform Camera u_camera;\nuniform Sphere u_iniSpheres[3];\nuniform Sphere u_inversionSphere;\nuniform Sphere u_convexSphere;\nuniform Sphere u_spheirahedraSpheres[6];\nuniform Sphere u_seedSpheres[8];\n\nvec3 calcRay (const vec3 eye, const vec3 target, const vec3 up, const float fov,\n              const vec2 resolution, const vec2 coord){\n    float imagePlane = (resolution.y * .5) / tan(fov * .5);\n    vec3 v = normalize(target - eye);\n    vec3 xaxis = normalize(cross(v, up));\n    vec3 yaxis =  normalize(cross(v, xaxis));\n    vec3 center = v * imagePlane;\n    vec3 origin = center - (xaxis * (resolution.x  *.5)) - (yaxis * (resolution.y * .5));\n    return normalize(origin + (xaxis * coord.x) + (yaxis * (resolution.y - coord.y)));\n}\n\nconst float DISPLAY_GAMMA_COEFF = 1. / 2.2;\nvec4 gammaCorrect(vec4 rgba) {\n    return vec4((min(pow(rgba.r, DISPLAY_GAMMA_COEFF), 1.)),\n                (min(pow(rgba.g, DISPLAY_GAMMA_COEFF), 1.)),\n                (min(pow(rgba.b, DISPLAY_GAMMA_COEFF), 1.)),\n                rgba.a);\n}\n\nstruct IsectInfo {\n    int objId;\n    int objIndex;\n    int objComponentId;\n    vec3 normal;\n    vec3 intersection;\n    float mint;\n    float maxt;\n    vec3 matColor;\n    bool hit;\n};\n\nfloat MAX_FLOAT = 1e20;\nconst float THRESHOLD = 0.001;\n\nIsectInfo newIsectInfo() {\n    IsectInfo isectInfo;\n    isectInfo.objId = -1;\n    isectInfo.objIndex = -1;\n    isectInfo.objComponentId = -1;\n    isectInfo.mint = MAX_FLOAT;\n    isectInfo.maxt = 9999999.;\n    isectInfo.hit = false;\n    return isectInfo;\n}\n\nbool intersectBBox(vec3 rayOrg, vec3 rayDir, vec3 boxMin, vec3 boxMax,\n                  out float hit0, out float hit1, out bool inBox) {\n\tfloat t0 = -1000000.0, t1 = 1000000.0;\n    hit0 = t0;\n    hit1 = t1;\n    inBox = false;\n    vec3 tNear = (boxMin - rayOrg) / rayDir;\n    vec3 tFar  = (boxMax - rayOrg) / rayDir;\n\n    if (tNear.x > tFar.x) {\n        float tmp = tNear.x;\n        tNear.x = tFar.x;\n        tFar.x = tmp;\n    }\n\n    t0 = max(tNear.x, t0);\n    t1 = min(tFar.x, t1);\n\n\n    if (tNear.y > tFar.y) {\n        float tmp = tNear.y;\n        tNear.y = tFar.y;\n        tFar.y = tmp;\n    }\n    t0 = max(tNear.y, t0);\n    t1 = min(tFar.y, t1);\n\n    if (tNear.z > tFar.z) {\n        float tmp = tNear.z;\n        tNear.z = tFar.z;\n        tFar.z = tmp;\n    }\n    t0 = max(tNear.z, t0);\n    t1 = min(tFar.z, t1);\n\n    if (t0 <= t1 && 0. < t1) {\n        if(t0 < 0.) inBox = true;\n        hit0 = t0;\n        hit1 = t1;\n        return true;\n    }\n    return false;\n}\n\nvec2 rand2n(const vec2 co, const float sampleIndex) {\n    vec2 seed = co * (sampleIndex + 1.0);\n    seed+=vec2(-1,1);\n    // implementation based on: lumina.sourceforge.net/Tutorials/Noise.html\n    return vec2(fract(sin(dot(seed.xy ,vec2(12.9898,78.233))) * 43758.5453),\n                fract(cos(dot(seed.xy ,vec2(4.898,7.23))) * 23421.631));\n}\n\nvec4 distUnion(vec4 t1, vec4 t2) {\n    return (t1.x < t2.x) ? t1 : t2;\n}\n\nfloat distPlane(const vec3 pos, const vec3 p, const vec3 normal) {\n    return dot(pos - p, normal);\n}\n\nconst int ID_PRISM = 0;\n\nfloat distPrism(const vec3 pos) {\n    float d = distPlane(pos, vec3(1, 0 ,0), normalize(vec3(sqrt(3.) * .5, 0., 1.5)));\n    d = max(distPlane(pos, vec3(1, 0 ,0), normalize(vec3(sqrt(3.) * .5, 0., -1.5))), d);\n    d = max(distPlane(pos, vec3(-0.5, 0 ,0), normalize(vec3(-1, 0, 0))), d);\n    return d;\n}\n\nfloat distSphere(const vec3 pos, const Sphere sphere, vec3 offset) {\n    return distance(pos, sphere.center + offset) - sphere.r.x;\n}\n\nfloat distInfSpheirahedra(const vec3 pos) {\n    float d = distPrism(pos);\n    d = max(-distSphere(pos, u_iniSpheres[0], vec3(0)), d);\n    d = max(-distSphere(pos, u_iniSpheres[1], vec3(0)), d);\n    d = max(-distSphere(pos, u_iniSpheres[2], vec3(0)), d);\n    return d;\n}\n\nfloat distSpheirahedra(vec3 pos) {\n    Sphere s;\n    float d = distSphere(pos, u_convexSphere, -u_convexSphere.center);\n    d = max(-distSphere(pos, u_spheirahedraSpheres[0], -u_convexSphere.center), d);\n    d = max(-distSphere(pos, u_spheirahedraSpheres[1], -u_convexSphere.center), d);\n    d = max(-distSphere(pos, u_spheirahedraSpheres[2], -u_convexSphere.center), d);\n    d = max(-distSphere(pos, u_spheirahedraSpheres[3], -u_convexSphere.center), d);\n    d = max(-distSphere(pos, u_spheirahedraSpheres[4], -u_convexSphere.center), d);\n    d = max(-distSphere(pos, u_spheirahedraSpheres[5], -u_convexSphere.center), d);\n    return d;\n}\n\nvec4 distFunc(const vec3 pos) {\n    vec4 hit = vec4(MAX_FLOAT, -1, -1, -1);\n    hit = distUnion(hit, vec4(distSpheirahedra(pos), ID_PRISM, -1, -1));\n    // for(int i = 0; i < 8; i++) {\n    //     hit = distUnion(hit, vec4(distSphere(pos, u_seedSpheres[i], -u_inversionSphere.center), ID_PRISM, -1, -1));\n    // }\n    return hit;\n}\n\nconst vec2 NORMAL_COEFF = vec2(0.00001, 0.);\nvec3 computeNormal(const vec3 p) {\n    return normalize(vec3(distFunc(p + NORMAL_COEFF.xyy).x - distFunc(p - NORMAL_COEFF.xyy).x,\n                          distFunc(p + NORMAL_COEFF.yxy).x - distFunc(p - NORMAL_COEFF.yxy).x,\n                          distFunc(p + NORMAL_COEFF.yyx).x - distFunc(p - NORMAL_COEFF.yyx).x));\n}\n\nconst int MAX_MARCHING_LOOP = 3000;\nconst float MARCHING_THRESHOLD = 0.0001;\nvoid march(const vec3 rayOrg, const vec3 rayDir, inout IsectInfo isectInfo) {\n    float rayLength = 0.;\n    vec3 rayPos = rayOrg + rayDir * rayLength;\n    vec4 dist = vec4(-1);\n    for(int i = 0 ; i < MAX_MARCHING_LOOP ; i++) {\n        if(rayLength > isectInfo.maxt ||\n           rayLength > isectInfo.mint) break;\n        dist = distFunc(rayPos);\n        rayLength += dist.x;\n        rayPos = rayOrg + rayDir * rayLength;\n        if(dist.x < MARCHING_THRESHOLD) {\n            isectInfo.objId = int(dist.y);\n            //isectInfo.objIndex = int(dist.z);\n            //isectInfo.objComponentId = int(dist.w);\n            // isectInfo.matColor = (g_invNum == 0.) ?\n            //     hsv2rgb(0.33, 1., .77) :\n            //     hsv2rgb(0.0 + g_invNum * 0.12 , 1., 1.);\n            isectInfo.intersection = rayPos;\n            isectInfo.normal = computeNormal(rayPos);\n            isectInfo.hit = true;\n            break;\n        }\n    }\n}\n\nconst vec3 AMBIENT_FACTOR = vec3(0.1);\nconst vec3 LIGHT_DIR = normalize(vec3(1, 1, 0));\nvec3 computeColor(const vec3 rayOrg, const vec3 rayDir) {\n    IsectInfo isectInfo = newIsectInfo();\n    vec3 rayPos = rayOrg;\n\n    vec3 l = vec3(0);\n\n    march(rayPos, rayDir, isectInfo);\n    if(isectInfo.hit) {\n        vec3 matColor = vec3(1);\n        vec3 diffuse =  clamp(dot(isectInfo.normal, LIGHT_DIR), 0., 1.) * matColor;\n        vec3 ambient = matColor * AMBIENT_FACTOR;\n        l += (diffuse) + ambient;\n    }\n\n    return l;\n}\n\nout vec4 outColor;\nvoid main() {\n    vec3 sum = vec3(0);\n    float MAX_SAMPLES = 10.;\n    for (float i = 0. ; i < MAX_SAMPLES ; i++) {\n        vec2 coordOffset = rand2n(gl_FragCoord.xy, i);\n        vec3 ray = calcRay(u_camera.pos, u_camera.target, u_camera.up, u_camera.fov,\n                           u_resolution, gl_FragCoord.xy + coordOffset);\n        sum += computeColor(u_camera.pos, ray);\n    }\n    outColor = gammaCorrect(vec4(sum / MAX_SAMPLES, 1.0));\n}\n"},function(e,t,n){"use strict";function r(e){return e&&e.__esModule?e:{default:e}}function i(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!t||"object"!=typeof t&&"function"!=typeof t?e:t}function s(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t)}function o(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}Object.defineProperty(t,"__esModule",{value:!0}),t.CameraOnSphere=t.Camera=void 0;var a=function(){function e(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}return function(t,n,r){return n&&e(t.prototype,n),r&&e(t,r),t}}(),c=n(0),u=r(c),h=n(1),f=r(h),l=t.Camera=function(){function e(t,n,r){o(this,e),this.pos=t,this.target=n,this.prevTarget=n,this.fov=r,this.up=new f.default(0,1,0)}return a(e,[{key:"computeRay",value:function(e,t,n,r){var i=.5*t/Math.tan(.5*this.fov),s=f.default.normalize(this.target.sub(this.pos)),o=f.default.normalize(f.default.cross(s,this.up)),a=f.default.normalize(f.default.cross(s,o)),c=s.scale(i),u=c.sub(o.scale(.5*e)).sub(a.scale(.5*t));return f.default.normalize(u.add(o.scale(n)).add(a.scale(r)))}},{key:"computeCoordOnScreen",value:function(e,t,n){var r=.5*n/Math.tan(.5*this.fov),i=f.default.normalize(this.target.sub(this.pos)),s=f.default.normalize(f.default.cross(i,this.up)),o=f.default.normalize(f.default.cross(i,s)),a=i.scale(r),c=a.sub(s.scale(.5*t)).sub(o.scale(.5*n)),h=f.default.normalize(e.sub(this.pos)),l=this.distToScreen(this.pos.add(a),i,this.pos,h),d=this.pos.add(h.scale(l)),p=d.sub(this.pos.add(c));return new u.default(f.default.dot(p,s),f.default.dot(p,o))}},{key:"computeVectorOnScreen",value:function(e,t,n,r){var i=.5*r/Math.tan(.5*this.fov),s=f.default.normalize(this.target.sub(this.pos)),o=f.default.normalize(f.default.cross(s,this.up)),a=f.default.normalize(f.default.cross(s,o)),c=s.scale(i),h=c.sub(o.scale(.5*n)).sub(a.scale(.5*r)),l=f.default.normalize(e.sub(this.pos)),d=this.distToScreen(this.pos.add(c),s,this.pos,l),p=this.pos.add(l.scale(d)),v=p.sub(this.pos.add(h)),m=new u.default(f.default.dot(v,o),f.default.dot(v,a));l=f.default.normalize(e.add(t.scale(50)).sub(this.pos)),d=this.distToScreen(this.pos.add(c),s,this.pos,l),p=this.pos.add(l.scale(d)),v=p.sub(this.pos.add(h));var y=new u.default(f.default.dot(v,o),f.default.dot(v,a));return u.default.normalize(y.sub(m))}},{key:"computeXAxisDirOnScreen",value:function(e,t,n){return this.computeVectorOnScreen(e,new f.default(1,0,0),t,n)}},{key:"computeYAxisDirOnScreen",value:function(e,t,n){return this.computeVectorOnScreen(e,new f.default(0,1,0),t,n)}},{key:"computeZAxisDirOnScreen",value:function(e,t,n){return this.computeVectorOnScreen(e,new f.default(0,0,1),t,n)}},{key:"getFocalXYVector",value:function(e,t){var n=f.default.normalize(this.target.sub(this.pos)),r=f.default.normalize(f.default.cross(n,this.up));return[r,f.default.normalize(f.default.cross(n,r))]}},{key:"distToScreen",value:function(e,t,n,r){var i=-f.default.dot(e,t),s=f.default.dot(t,r);return-(f.default.dot(t,n)+i)/s}},{key:"setUniformLocations",value:function(e,t,n){t.push(e.getUniformLocation(n,"u_camera.pos")),t.push(e.getUniformLocation(n,"u_camera.target")),t.push(e.getUniformLocation(n,"u_camera.fov")),t.push(e.getUniformLocation(n,"u_camera.up"))}},{key:"setUniformValues",value:function(e,t,n){return e.uniform3f(t[n++],this.pos.x,this.pos.y,this.pos.z),e.uniform3f(t[n++],this.target.x,this.target.y,this.target.z),e.uniform1f(t[n++],this.fov),e.uniform3f(t[n++],this.up.x,this.up.y,this.up.z),n}}]),e}();t.CameraOnSphere=function(e){function t(e,n,r,s){o(this,t);var a=i(this,(t.__proto__||Object.getPrototypeOf(t)).call(this,new f.default(0,0,0),e,n));return a.target=e,a.fov=n,a.cameraDistance=r,a.up=s,a.theta=0,a.phi=0,a.prevThetaPhi=new u.default(a.theta,a.phi),a.update(),a}return s(t,e),a(t,[{key:"update",value:function(){this.pos=new f.default(this.cameraDistance*Math.cos(this.phi)*Math.cos(this.theta),this.cameraDistance*Math.sin(this.phi),-this.cameraDistance*Math.cos(this.phi)*Math.sin(this.theta)),this.pos=this.target.add(this.pos),Math.abs(this.phi)%(2*Math.PI)>Math.PI/2&&Math.abs(this.phi)%(2*Math.PI)<3*Math.PI/2?this.up=new f.default(0,-1,0):this.up=new f.default(0,1,0)}}]),t}(l)},function(e,t,n){"use strict";function r(e){return e&&e.__esModule?e:{default:e}}var i=n(6),s=r(i),o=n(5),a=r(o),c=n(7),u=r(c),h=(n(10),n(11)),f=n(8),l=n(9);window.addEventListener("load",function(){var e=new u.default(0,Math.sqrt(3)/2),t=new s.default("canvas",e,h),n=new s.default("canvas2",e,f),r=new a.default("parameterCanvas",e,l);t.render(),n.render(),r.render()})},function(e,t,n){"use strict";function r(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}Object.defineProperty(t,"__esModule",{value:!0});var i=function(){function e(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}return function(t,n,r){return n&&e(t.prototype,n),r&&e(t,r),t}}(),s=n(1),o=function(e){return e&&e.__esModule?e:{default:e}}(s),a=function(){function e(t,n,i,s){r(this,e),this.center=new o.default(t,n,i),this.r=s,this.update(),this.basisRadius=20}return i(e,[{key:"update",value:function(){this.rSq=this.r*this.r}},{key:"setObjBasisUniformValues",value:function(e,t,n){return e.uniform3f(t[n++],this.center.x,this.center.y,this.center.z),e.uniform1f(t[n++],this.basisRadius),e.uniform1f(t[n++],this.r),e.uniform1i(t[n++],!1),e.uniform2f(t[n++],0,0),n}},{key:"setUniformValues",value:function(e,t,n){var r=n;return e.uniform3f(t[r++],this.center.x,this.center.y,this.center.z),e.uniform2f(t[r++],this.r,this.rSq),e.uniform1i(t[r++],this.selected),r}},{key:"cloneDeeply",value:function(){var t=new e(this.center.x,this.center.y,this.center.z,this.r);return t.selected=this.selected,t}},{key:"invertOnPoint",value:function(e){var t=e.sub(this.center),n=t.length();return t.scale(this.rSq/(n*n)).add(this.center)}},{key:"invertOnSphere",value:function(t){var n=t.r,r=Math.sqrt(3),i=n*r/3,s=this.invertOnPoint(t.center.add(new o.default(i,i,i))),a=this.invertOnPoint(t.center.add(new o.default(-i,-i,-i))),c=this.invertOnPoint(t.center.add(new o.default(i,-i,-i))),u=this.invertOnPoint(t.center.add(new o.default(i,i,-i)));return e.fromPoints(s,a,c,u)}},{key:"invertOnPlane",value:function(t,n,r){return e.fromPoints(this.invertOnPoint(t),this.invertOnPoint(n),this.invertOnPoint(r),this.center)}}],[{key:"pivoting",value:function(e,t,n){for(var r=n,i=Math.abs(e[n][n]),s=n+1;s<t;s++)Math.abs(e[s][n])>i&&(r=s,i=Math.abs(e[s][n]));if(n!==r){var o=e[r];e[r]=e[n],e[n]=o}return e}},{key:"fromPoints",value:function(t,n,r,i){for(var s=[t,n,r,i],a=[[],[],[]],c=0;c<3;c++)a[c][0]=2*(s[c+1].x-s[c].x),a[c][1]=2*(s[c+1].y-s[c].y),a[c][2]=2*(s[c+1].z-s[c].z),a[c][3]=-(Math.pow(s[c].x,2)+Math.pow(s[c].y,2)+Math.pow(s[c].z,2))+Math.pow(s[c+1].x,2)+Math.pow(s[c+1].y,2)+Math.pow(s[c+1].z,2);for(var u=0;u<2;u++){a=e.pivoting(a,3,u);for(var h=a[u][u],f=u+1;f<3;f++)for(var l=a[f][u],d=u;d<4;++d)a[f][d]=a[f][d]-l*(a[u][d]/h)}a[2][3]=a[2][3]/a[2][2];for(var p=1;p>=0;p--){for(var v=0,m=p+1;m<3;m++)v+=a[p][m]*a[m][3];a[p][3]=(a[p][3]-v)/a[p][p]}var y=new o.default(a[0][3],a[1][3],a[2][3]),x=y.sub(t).length();return new e(y.x,y.y,y.z,x)}}]),e}();t.default=a}]);